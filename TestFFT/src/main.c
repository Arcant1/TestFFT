/* Copyright 2016, Eric Pernia.

 * All rights reserved.
 *
 * This file is part sAPI library for microcontrollers.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the copyright holder nor the names of its
 *    contributors may be used to endorse or promote products derived from this
 *    software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 */

/*
 * Date: 2016-04-26
 */

/*==================[inclusions]=============================================*/

#include "main.h"         /* <= own header */
#include "math.h"
#include "sAPI.h"         /* <= sAPI header */
#include "ledsManager.h"

#define dosFIX_MPY(DEST,A,B)       {       \
        _DX = (B);                      \
        _AX = (A);                      \
        asm imul dx;                    \
        asm add ax,ax;                  \
        asm adc dx,dx;                  \
        DEST = _DX;             }

#define FIX_MPY(DEST,A,B)       DEST = ((long)(A) * (long)(B))>>15

#define N_WAVE          1024    /* dimension de Sinewave[] */
#define LOG2_N_WAVE     10      /* log2(N_WAVE) */
#define N_LOUD          100     /* dimension de Loudampl[] */
#ifndef fixed
#define fixed int
#endif

extern fixed Sinewave[N_WAVE];
uint8_t asdf[8] = { 4, 4, 4, 4, 4, 4, 4, 4 };
fixed fix_mpy(fixed a, fixed b);
///////////////////COEF FILTROS
#define ORDEN 100

const int32_t coeffil7[100] = { -5742946, 4474223, -3962371, -13261990, 9500239,
		-2022765, 230459, 363060, 1817661, 34256, -9057956, 12943143, -2912139,
		-12945973, 18823157, -9040015, -4333824, 6274419, 710902, -37427,
		-14123769, 24546781, -11125399, -19915518, 37906196, -23456512,
		-6210624, 18001098, -5842888, -1365846, -18414407, 43068470, -28844986,
		-28818211, 76443711, -60571967, -3943756, 46856212, -30085496, -338270,
		-24260955, 88509208, -86391253, -49303195, 226610147, -251157771,
		34232941, 271716458, -387584988, 181619800, 181619800, -387584988,
		271716458, 34232941, -251157771, 226610147, -49303195, -86391253,
		88509208, -24260955, -338270, -30085496, 46856212, -3943756, -60571967,
		76443711, -28818211, -28844986, 43068470, -18414407, -1365846, -5842888,
		18001098, -6210624, -23456512, 37906196, -19915518, -11125399, 24546781,
		-14123769, -37427, 710902, 6274419, -4333824, -9040015, 18823157,
		-12945973, -2912139, 12943143, -9057956, 34256, 1817661, 363060, 230459,
		-2022765, 9500239, -13261990, -3962371, 4474223, -5742946 };

const int32_t coeffil8[100] = { 4210672, 10398482, -6465123, 4368211, -1750291,
		-1523598, 4544776, -6105079, 5339792, -2205289, -2351145, 6635817,
		-8810038, 7647610, -3137364, -3331183, 9354624, -12366218, 10690778,
		-4369177, -4636447, 12984019, -17134618, 14799782, -6046075, -6424185,
		17994722, -23786541, 20594644, -8435560, -9012609, 25372030, -33752797,
		29451021, -12171587, -13172723, 37568139, -50796637, 45184349,
		-19120717, -21293872, 62883497, -88765811, 83417316, -37883004,
		-46479098, 157090413, -272628861, 368302260, -422436929, 422436929,
		-368302260, 272628861, -157090413, 46479098, 37883004, -83417316,
		88765811, -62883497, 21293872, 19120717, -45184349, 50796637, -37568139,
		13172723, 12171587, -29451021, 33752797, -25372030, 9012609, 8435560,
		-20594644, 23786541, -17994722, 6424185, 6046075, -14799782, 17134618,
		-12984019, 4636447, 4369177, -10690778, 12366218, -9354624, 3331183,
		3137364, -7647610, 8810038, -6635817, 2351145, 2205289, -5339792,
		6105079, -4544776, 1523598, 1750291, -4368211, 6465123, -10398482,
		-4210672 };

const int32_t coeffil6[100] = { 9512732, -2735177, 432786, -3206985, -9258854,
		582983, 10361889, -4592898, -14182093, 2429340, 8164752, -2183898,
		-58474, -2668716, -12704429, 5946199, 20565695, -9106423, -21466174,
		7141382, 10642106, -1131644, 7747506, -8986918, -27852826, 18053908,
		39061547, -21489671, -34211738, 14268411, 10737758, 3765388, 24683373,
		-28014909, -58660022, 47950939, 74039797, -50991259, -57088111,
		26326532, 2707534, 29576106, 81837214, -110394285, -178495926,
		199883054, 263348539, -276257057, -314421239, 318677554, 318677554,
		-314421239, -276257057, 263348539, 199883054, -178495926, -110394285,
		81837214, 29576106, 2707534, 26326532, -57088111, -50991259, 74039797,
		47950939, -58660022, -28014909, 24683373, 3765388, 10737758, 14268411,
		-34211738, -21489671, 39061547, 18053908, -27852826, -8986918, 7747506,
		-1131644, 10642106, 7141382, -21466174, -9106423, 20565695, 5946199,
		-12704429, -2668716, -58474, -2183898, 8164752, 2429340, -14182093,
		-4592898, 10361889, 582983, -9258854, -3206985, 432786, -2735177,
		9512732 };

const int32_t coeffil5[100] = { -1753133, -14596186, -237159, 1890058, 2473848,
		407746, 553284, 3394282, 2841833, -4743939, -12018306, -7409406,
		8473846, 19263039, 10933468, -9386240, -19867585, -10178919, 6088663,
		10090734, 2707895, 837717, 9541308, 11133942, -8757550, -32850373,
		-26890133, 13986975, 49063329, 36340270, -13588289, -46385086,
		-29934014, 6983822, 16930982, 715884, 3471512, 39117778, 51851820,
		-13330829, -111992946, -119921922, 18084170, 184666277, 188410693,
		-15307718, -238157712, -239370889, 5970016, 258017708, 258017708,
		5970016, -239370889, -238157712, -15307718, 188410693, 184666277,
		18084170, -119921922, -111992946, -13330829, 51851820, 39117778,
		3471512, 715884, 16930982, 6983822, -29934014, -46385086, -13588289,
		36340270, 49063329, 13986975, -26890133, -32850373, -8757550, 11133942,
		9541308, 837717, 2707895, 10090734, 6088663, -10178919, -19867585,
		-9386240, 10933468, 19263039, 8473846, -7409406, -12018306, -4743939,
		2841833, 3394282, 553284, 407746, 2473848, 1890058, -237159, -14596186,
		-1753133 };

const int32_t coeffil4[100] = { -8487929, 5654165, 562935, -4460972, -8312340,
		-9364294, -6384393, 236217, 8026710, 13366428, 13460239, 8146430,
		257586, -5925701, -7351745, -4274355, -247448, 242281, -4867680,
		-13114009, -18352469, -14460295, 217351, 20615893, 36799284, 39336024,
		25172607, 240929, -23274853, -33922490, -28001024, -12282361, 216921,
		-1047032, -15943278, -31821740, -30345587, 205259, 54357802, 107889104,
		128052881, 91473961, 231830, -113771322, -200381082, -214505082,
		-139752572, 198945, 149576047, 245025152, 245025152, 149576047, 198945,
		-139752572, -214505082, -200381082, -113771322, 231830, 91473961,
		128052881, 107889104, 54357802, 205259, -30345587, -31821740, -15943278,
		-1047032, 216921, -12282361, -28001024, -33922490, -23274853, 240929,
		25172607, 39336024, 36799284, 20615893, 217351, -14460295, -18352469,
		-13114009, -4867680, 242281, -247448, -4274355, -7351745, -5925701,
		257586, 8146430, 13460239, 13366428, 8026710, 236217, -6384393,
		-9364294, -8312340, -4460972, 562935, 5654165, -8487929 };

const int32_t coeffil3[100] = { 8938331, 8777665, 6900756, 9988296, 6744235,
		6636042, 1455163, -1208650, -7100276, -10085443, -14251715, -14921417,
		-15391159, -12576111, -9557211, -4648988, -751500, 3035621, 4483875,
		4579642, 2267875, -827252, -4556347, -6881793, -7188056, -3912564,
		2870751, 13279623, 25789050, 38830899, 49738547, 56214398, 55829751,
		47298221, 30121134, 5439945, -24506523, -56115784, -85270478,
		-107562401, -119261806, -117675893, -101869664, -72727022, -33112594,
		12583104, 58889237, 100074086, 130894090, 147378046, 147378046,
		130894090, 100074086, 58889237, 12583104, -33112594, -72727022,
		-101869664, -117675893, -119261806, -107562401, -85270478, -56115784,
		-24506523, 5439945, 30121134, 47298221, 55829751, 56214398, 49738547,
		38830899, 25789050, 13279623, 2870751, -3912564, -7188056, -6881793,
		-4556347, -827252, 2267875, 4579642, 4483875, 3035621, -751500,
		-4648988, -9557211, -12576111, -15391159, -14921417, -14251715,
		-10085443, -7100276, -1208650, 1455163, 6636042, 6744235, 9988296,
		6900756, 8777665, 8938331 };

const int32_t coeffil2[100] = { 522781, -48427454, -15468266, -16485945,
		-17227973, -17200425, -16299883, -14465242, -11687760, -8010759,
		-3525536, 1626599, 7247784, 13088747, 18887040, 24362599, 29186906,
		33095422, 35804550, 37100259, 36814876, 34849660, 31186468, 25891125,
		19112356, 11078246, 2092692, -7472698, -17214296, -26682790, -35437980,
		-43043917, -49099373, -53274548, -55306747, -55027850, -52379713,
		-47415201, -40293280, -31274157, -20716080, -9065809, 3215179, 15490614,
		27356490, 38174246, 47464165, 54843328, 59980501, 62619793, 62619793,
		59980501, 54843328, 47464165, 38174246, 27356490, 15490614, 3215179,
		-9065809, -20716080, -31274157, -40293280, -47415201, -52379713,
		-55027850, -55306747, -53274548, -49099373, -43043917, -35437980,
		-26682790, -17214296, -7472698, 2092692, 11078246, 19112356, 25891125,
		31186468, 34849660, 36814876, 37100259, 35804550, 33095422, 29186906,
		24362599, 18887040, 13088747, 7247784, 1626599, -3525536, -8010759,
		-11687760, -14465242, -16299883, -17200425, -17227973, -16485945,
		-15468266, -48427454, 522781 };

const int32_t coeffil1[100] = { 67308373, 6423257, 6372676, 6067471, 5500717,
		4661641, 3559126, 2195204, 589424, -1231669, -3235839, -5381480,
		-7616226, -9885115, -12135015, -14308781, -16360400, -18229250,
		-19827918, -20974968, -21857572, -22220170, -22085330, -21391282,
		-20110104, -18199580, -15652765, -12460363, -8625931, -4170286, 870443,
		6454709, 12531419, 19037499, 25901202, 33027817, 40315902, 47669849,
		55026512, 62218304, 69186838, 75805737, 81987358, 87616302, 92630750,
		96932411, 100455728, 103151031, 104977573, 105899321, 105899321,
		104977573, 103151031, 100455728, 96932411, 92630750, 87616302, 81987358,
		75805737, 69186838, 62218304, 55026512, 47669849, 40315902, 33027817,
		25901202, 19037499, 12531419, 6454709, 870443, -4170286, -8625931,
		-12460363, -15652765, -18199580, -20110104, -21391282, -22085330,
		-22220170, -21857572, -20974968, -19827918, -18229250, -16360400,
		-14308781, -12135015, -9885115, -7616226, -5381480, -3235839, -1231669,
		589424, 2195204, 3559126, 4661641, 5500717, 6067471, 6372676, 6423257,
		67308373 };
///////////////////COEF FILTROS

int fix_fft(int fr[], int fi[], int m, int inverse) {
	int mr, nn, i, j, l, k, istep, n, scale, shift;
	fixed qr, qi, tr, ti, wr, wi;

	n = 1 << m;

	if (n > N_WAVE)
		return -1;

	mr = 0;
	nn = n - 1;
	scale = 0;

//diezmado
	for (m = 1; m <= nn; ++m) {
		l = n;
		do {
			l >>= 1;
		} while (mr + l > nn);
		mr = (mr & (l - 1)) + l;

		if (mr <= m)
			continue;
		tr = fr[m];
		fr[m] = fr[mr];
		fr[mr] = tr;
		ti = fi[m];
		fi[m] = fi[mr];
		fi[mr] = ti;
	}

	l = 1;
	k = LOG2_N_WAVE - 1;
	while (l < n) {
		if (inverse) {
//escalo segun
			shift = 0;
			for (i = 0; i < n; ++i) {
				j = fr[i];
				if (j < 0)
					j = -j;
				m = fi[i];
				if (m < 0)
					m = -m;
				if (j > 16383 || m > 16383) {
					shift = 1;
					break;
				}
			}
			if (shift)
				++scale;
		} else {
			shift = 1;
		}

		istep = l << 1;
		for (m = 0; m < l; ++m) {
			j = m << k;
			wr = Sinewave[j + N_WAVE / 4];
			wi = -Sinewave[j];
			if (inverse)
				wi = -wi;
			if (shift) {
				wr >>= 1;
				wi >>= 1;
			}
			for (i = m; i < n; i += istep) {
				j = i + l;
				tr = fix_mpy(wr, fr[j]) - fix_mpy(wi, fi[j]);
				ti = fix_mpy(wr, fi[j]) + fix_mpy(wi, fr[j]);
				qr = fr[i];
				qi = fi[i];
				if (shift) {
					qr >>= 1;
					qi >>= 1;
				}
				fr[j] = qr - tr;
				fi[j] = qi - ti;
				fr[i] = qr + tr;
				fi[i] = qi + ti;
			}
		}
		--k;
		l = istep;
	}

	return scale;
}

/*      aplico ventana de hanning al vector de muestras       */
void window(fixed fr[], int n) {
	int i, j, k;

	j = N_WAVE / n;
	n >>= 1;
	for (i = 0, k = N_WAVE / 4; i < n; ++i, k += j)
		FIX_MPY(fr[i], fr[i], 16384 - (Sinewave[k] >> 1));
	n <<= 1;
	for (k -= j; i < n; ++i, k -= j)
		FIX_MPY(fr[i], fr[i], 16384 - (Sinewave[k] >> 1));
}



/*
 rutina assembler
 */
fixed fix_mpy(fixed a, fixed b) {
	FIX_MPY(a, a, b);
	return a;
}



/*
producto punto */
fixed fix_dot(fixed *hpa, fixed *pb, int n) {
	fixed *pa;
	long sum;
	register fixed a, b;
	sum = 0L;
	while (n--) {
		a = *pa++;
		b = *pb++;
		FIX_MPY(a, a, b);
		sum += a;
	}

	if (sum > 0x7FFF)
		sum = 0x7FFF;
	else if (sum < -0x7FFF)
		sum = -0x7FFF;

	return (fixed) sum;
#ifdef  DOS
	asm push ds
	asm lds si,hpa
	asm les di,pb
	asm xor bx,bx

	asm xor cx,cx

	loop:
	asm lodsw
	.
	asm imul word ptr es:[di]
	asm add bx,ax
	asm adc cx,dx
	asm jo overflow
	asm add di,2
	asm dec word ptr n
	asm jg loop

	asm add bx,bx
	asm adc cx,cx
	asm jo overflow

	asm pop ds
	return _CX;

	overflow:
	asm mov cx,7FFFH
	asm adc cx,0

	asm pop ds
	return _CX;
#endif

}

#if N_WAVE != 1024
ERROR: N_WAVE != 1024
#endif
fixed Sinewave[1024] = { 0, 201, 402, 603, 804, 1005, 1206, 1406, 1607, 1808,
		2009, 2209, 2410, 2610, 2811, 3011, 3211, 3411, 3611, 3811, 4011, 4210,
		4409, 4608, 4807, 5006, 5205, 5403, 5601, 5799, 5997, 6195, 6392, 6589,
		6786, 6982, 7179, 7375, 7571, 7766, 7961, 8156, 8351, 8545, 8739, 8932,
		9126, 9319, 9511, 9703, 9895, 10087, 10278, 10469, 10659, 10849, 11038,
		11227, 11416, 11604, 11792, 11980, 12166, 12353, 12539, 12724, 12909,
		13094, 13278, 13462, 13645, 13827, 14009, 14191, 14372, 14552, 14732,
		14911, 15090, 15268, 15446, 15623, 15799, 15975, 16150, 16325, 16499,
		16672, 16845, 17017, 17189, 17360, 17530, 17699, 17868, 18036, 18204,
		18371, 18537, 18702, 18867, 19031, 19194, 19357, 19519, 19680, 19840,
		20000, 20159, 20317, 20474, 20631, 20787, 20942, 21096, 21249, 21402,
		21554, 21705, 21855, 22004, 22153, 22301, 22448, 22594, 22739, 22883,
		23027, 23169, 23311, 23452, 23592, 23731, 23869, 24006, 24143, 24278,
		24413, 24546, 24679, 24811, 24942, 25072, 25201, 25329, 25456, 25582,
		25707, 25831, 25954, 26077, 26198, 26318, 26437, 26556, 26673, 26789,
		26905, 27019, 27132, 27244, 27355, 27466, 27575, 27683, 27790, 27896,
		28001, 28105, 28208, 28309, 28410, 28510, 28608, 28706, 28802, 28897,
		28992, 29085, 29177, 29268, 29358, 29446, 29534, 29621, 29706, 29790,
		29873, 29955, 30036, 30116, 30195, 30272, 30349, 30424, 30498, 30571,
		30643, 30713, 30783, 30851, 30918, 30984, 31049, 31113, 31175, 31236,
		31297, 31356, 31413, 31470, 31525, 31580, 31633, 31684, 31735, 31785,
		31833, 31880, 31926, 31970, 32014, 32056, 32097, 32137, 32176, 32213,
		32249, 32284, 32318, 32350, 32382, 32412, 32441, 32468, 32495, 32520,
		32544, 32567, 32588, 32609, 32628, 32646, 32662, 32678, 32692, 32705,
		32717, 32727, 32736, 32744, 32751, 32757, 32761, 32764, 32766, 32767,
		32766, 32764, 32761, 32757, 32751, 32744, 32736, 32727, 32717, 32705,
		32692, 32678, 32662, 32646, 32628, 32609, 32588, 32567, 32544, 32520,
		32495, 32468, 32441, 32412, 32382, 32350, 32318, 32284, 32249, 32213,
		32176, 32137, 32097, 32056, 32014, 31970, 31926, 31880, 31833, 31785,
		31735, 31684, 31633, 31580, 31525, 31470, 31413, 31356, 31297, 31236,
		31175, 31113, 31049, 30984, 30918, 30851, 30783, 30713, 30643, 30571,
		30498, 30424, 30349, 30272, 30195, 30116, 30036, 29955, 29873, 29790,
		29706, 29621, 29534, 29446, 29358, 29268, 29177, 29085, 28992, 28897,
		28802, 28706, 28608, 28510, 28410, 28309, 28208, 28105, 28001, 27896,
		27790, 27683, 27575, 27466, 27355, 27244, 27132, 27019, 26905, 26789,
		26673, 26556, 26437, 26318, 26198, 26077, 25954, 25831, 25707, 25582,
		25456, 25329, 25201, 25072, 24942, 24811, 24679, 24546, 24413, 24278,
		24143, 24006, 23869, 23731, 23592, 23452, 23311, 23169, 23027, 22883,
		22739, 22594, 22448, 22301, 22153, 22004, 21855, 21705, 21554, 21402,
		21249, 21096, 20942, 20787, 20631, 20474, 20317, 20159, 20000, 19840,
		19680, 19519, 19357, 19194, 19031, 18867, 18702, 18537, 18371, 18204,
		18036, 17868, 17699, 17530, 17360, 17189, 17017, 16845, 16672, 16499,
		16325, 16150, 15975, 15799, 15623, 15446, 15268, 15090, 14911, 14732,
		14552, 14372, 14191, 14009, 13827, 13645, 13462, 13278, 13094, 12909,
		12724, 12539, 12353, 12166, 11980, 11792, 11604, 11416, 11227, 11038,
		10849, 10659, 10469, 10278, 10087, 9895, 9703, 9511, 9319, 9126, 8932,
		8739, 8545, 8351, 8156, 7961, 7766, 7571, 7375, 7179, 6982, 6786, 6589,
		6392, 6195, 5997, 5799, 5601, 5403, 5205, 5006, 4807, 4608, 4409, 4210,
		4011, 3811, 3611, 3411, 3211, 3011, 2811, 2610, 2410, 2209, 2009, 1808,
		1607, 1406, 1206, 1005, 804, 603, 402, 201, 0, -201, -402, -603, -804,
		-1005, -1206, -1406, -1607, -1808, -2009, -2209, -2410, -2610, -2811,
		-3011, -3211, -3411, -3611, -3811, -4011, -4210, -4409, -4608, -4807,
		-5006, -5205, -5403, -5601, -5799, -5997, -6195, -6392, -6589, -6786,
		-6982, -7179, -7375, -7571, -7766, -7961, -8156, -8351, -8545, -8739,
		-8932, -9126, -9319, -9511, -9703, -9895, -10087, -10278, -10469,
		-10659, -10849, -11038, -11227, -11416, -11604, -11792, -11980, -12166,
		-12353, -12539, -12724, -12909, -13094, -13278, -13462, -13645, -13827,
		-14009, -14191, -14372, -14552, -14732, -14911, -15090, -15268, -15446,
		-15623, -15799, -15975, -16150, -16325, -16499, -16672, -16845, -17017,
		-17189, -17360, -17530, -17699, -17868, -18036, -18204, -18371, -18537,
		-18702, -18867, -19031, -19194, -19357, -19519, -19680, -19840, -20000,
		-20159, -20317, -20474, -20631, -20787, -20942, -21096, -21249, -21402,
		-21554, -21705, -21855, -22004, -22153, -22301, -22448, -22594, -22739,
		-22883, -23027, -23169, -23311, -23452, -23592, -23731, -23869, -24006,
		-24143, -24278, -24413, -24546, -24679, -24811, -24942, -25072, -25201,
		-25329, -25456, -25582, -25707, -25831, -25954, -26077, -26198, -26318,
		-26437, -26556, -26673, -26789, -26905, -27019, -27132, -27244, -27355,
		-27466, -27575, -27683, -27790, -27896, -28001, -28105, -28208, -28309,
		-28410, -28510, -28608, -28706, -28802, -28897, -28992, -29085, -29177,
		-29268, -29358, -29446, -29534, -29621, -29706, -29790, -29873, -29955,
		-30036, -30116, -30195, -30272, -30349, -30424, -30498, -30571, -30643,
		-30713, -30783, -30851, -30918, -30984, -31049, -31113, -31175, -31236,
		-31297, -31356, -31413, -31470, -31525, -31580, -31633, -31684, -31735,
		-31785, -31833, -31880, -31926, -31970, -32014, -32056, -32097, -32137,
		-32176, -32213, -32249, -32284, -32318, -32350, -32382, -32412, -32441,
		-32468, -32495, -32520, -32544, -32567, -32588, -32609, -32628, -32646,
		-32662, -32678, -32692, -32705, -32717, -32727, -32736, -32744, -32751,
		-32757, -32761, -32764, -32766, -32767, -32766, -32764, -32761, -32757,
		-32751, -32744, -32736, -32727, -32717, -32705, -32692, -32678, -32662,
		-32646, -32628, -32609, -32588, -32567, -32544, -32520, -32495, -32468,
		-32441, -32412, -32382, -32350, -32318, -32284, -32249, -32213, -32176,
		-32137, -32097, -32056, -32014, -31970, -31926, -31880, -31833, -31785,
		-31735, -31684, -31633, -31580, -31525, -31470, -31413, -31356, -31297,
		-31236, -31175, -31113, -31049, -30984, -30918, -30851, -30783, -30713,
		-30643, -30571, -30498, -30424, -30349, -30272, -30195, -30116, -30036,
		-29955, -29873, -29790, -29706, -29621, -29534, -29446, -29358, -29268,
		-29177, -29085, -28992, -28897, -28802, -28706, -28608, -28510, -28410,
		-28309, -28208, -28105, -28001, -27896, -27790, -27683, -27575, -27466,
		-27355, -27244, -27132, -27019, -26905, -26789, -26673, -26556, -26437,
		-26318, -26198, -26077, -25954, -25831, -25707, -25582, -25456, -25329,
		-25201, -25072, -24942, -24811, -24679, -24546, -24413, -24278, -24143,
		-24006, -23869, -23731, -23592, -23452, -23311, -23169, -23027, -22883,
		-22739, -22594, -22448, -22301, -22153, -22004, -21855, -21705, -21554,
		-21402, -21249, -21096, -20942, -20787, -20631, -20474, -20317, -20159,
		-20000, -19840, -19680, -19519, -19357, -19194, -19031, -18867, -18702,
		-18537, -18371, -18204, -18036, -17868, -17699, -17530, -17360, -17189,
		-17017, -16845, -16672, -16499, -16325, -16150, -15975, -15799, -15623,
		-15446, -15268, -15090, -14911, -14732, -14552, -14372, -14191, -14009,
		-13827, -13645, -13462, -13278, -13094, -12909, -12724, -12539, -12353,
		-12166, -11980, -11792, -11604, -11416, -11227, -11038, -10849, -10659,
		-10469, -10278, -10087, -9895, -9703, -9511, -9319, -9126, -8932, -8739,
		-8545, -8351, -8156, -7961, -7766, -7571, -7375, -7179, -6982, -6786,
		-6589, -6392, -6195, -5997, -5799, -5601, -5403, -5205, -5006, -4807,
		-4608, -4409, -4210, -4011, -3811, -3611, -3411, -3211, -3011, -2811,
		-2610, -2410, -2209, -2009, -1808, -1607, -1406, -1206, -1005, -804,
		-603, -402, -201, };



/*****************************************FILTRO*************************************************/
#define SATURACION 460
#define CantMuestras 1024
#define MAXCYCLE 400
#define M       10
#define N       (1024)
#define CANTSENOS N
#define BANDAS 16
#define fixed short

//char coefs[8];

int senial[1024];
int ultimaMuestra;
unsigned int refreshCounter;
unsigned int nrInterrupts;
unsigned char calculationFlag;
int real[N], imag[N];
unsigned int energia[N];
unsigned char bandas[BANDAS / 2];

const unsigned char todoUNO[8] = { 1, 1, 1, 1, 1, 1, 1, 1 };
unsigned char todoOCHO[8] = { 8, 8, 8, 8, 8, 8, 8, 8 };

int adcFlag;
int oldestSample = 0;
int i;
int32_t coeffil[100];
uint8_t flagCambioFiltros = 1;
int64_t buff[ORDEN] = { 0 }, senalFiltrada[8], senalSalida;
uint8_t vfiltros[8] = { 4, 4, 4, 4, 4, 4, 4, 4 };
char muestra;
typedef enum {
	MOSTRARFFT, CAMBIARFILTROS, MOSTRARFILTRADO
} estados;
estados state = MOSTRARFFT;
extern unsigned char receivedByte;

int64_t filtrar(int32_t * vec, int dim, int atenFOR, int atenOFF, int offset) {
	int i;
	int64_t filtrada = 0;
	for (i = 0; i < dim; i++) {
		filtrada += (((int64_t) buff[(oldestSample + i) % dim]
				* (int64_t) vec[i]) >> atenFOR);
	}

	filtrada >>= atenOFF;
	senalSalida += offset;
	senial[nrInterrupts % CantMuestras] = filtrada;
	muestra = 1;
	filtrada += 512;

	return filtrada;
}

void calcularSalida(uint8_t* vfiltros) //arreglo de numeros entre 0 y 8 obtenido por bt
{
	for (i = 0; i < ORDEN; i++) {
		coeffil[i] = ((vfiltros[0] * coeffil1[i]) >> 3)
				+ ((vfiltros[1] * coeffil2[i]) >> 2)
				+ ((vfiltros[2] * coeffil3[i]) >> 2)
				+ ((vfiltros[3] * coeffil4[i]) >> 2)
				+ ((vfiltros[4] * coeffil5[i]) >> 2)
				+ ((vfiltros[5] * coeffil6[i]) >> 2)
				+ ((vfiltros[6] * coeffil7[i]) >> 2)
				+ ((vfiltros[7] * coeffil8[i]) >> 2);
	}
}

int mostrarFiltrado(void) {

	if (flagCambioFiltros) {
		flagCambioFiltros = 0;
		calcularSalida(vfiltros);
	}
	if (state == MOSTRARFILTRADO) {
		if (calculationFlag == 1) {
			calcularBandas();
			calculationFlag = 0;
		}

		if (muestra) {
			ledsControl(bandas);
		} else
			ledsControl(todoUNO);

	}
	return 0;

}
/***********************************SPECTRUM*****************************************************/

int kb_abs(int num) { //calcula el valor absoluto rapidito ANDA BIEN
	int mascara = num >> 31;
	return (mascara + num) ^ mascara;
}
void TIMER_IRQ(void) { //TODO: ADC_IRQ
	nrInterrupts++;
	if (state == MOSTRARFFT) {

		ultimaMuestra = (uint16_t) adcRead(ADC0);
		dacWrite(DAC, (uint16_t) ultimaMuestra);
		ultimaMuestra -= 511;
		senial[nrInterrupts % CantMuestras] = ultimaMuestra;

		if ((nrInterrupts % MAXCYCLE) == 0) {
			calculationFlag = 1;
		}
		ultimaMuestra = kb_abs(ultimaMuestra);

		muestra = (ultimaMuestra > 10) ? 1 : 0;

	} else {
		senalSalida = 0;
//		for (i = 0; i < 8; i++)
//			senalFiltrada[i] = 0;
		buff[oldestSample++] = adcRead(ADC0);
		if ((nrInterrupts % MAXCYCLE) == 0) {
			calculationFlag = 1;
		}
		oldestSample %= ORDEN;
		senalSalida = filtrar(coeffil, ORDEN, 16, 16, 0);

		if (senalSalida > 1023) {
			gpioWrite(LED1, ON);
		} else {
			gpioWrite(LED1, OFF);
		}

		dacWrite(DAC, (uint16_t) senalSalida);

	}

}
void setup() { //TODO: setup
	boardConfig();
	int k;

	shiftBoardInit();
	gpioConfig(LEDR, OUTPUT);
	gpioConfig(LEDG, OUTPUT);
	gpioConfig(LEDB, OUTPUT);
	gpioConfig(LED1, OUTPUT);
	gpioConfig(LED2, OUTPUT);
	gpioConfig(LED3, OUTPUT);

	refreshCounter = 0;
	nrInterrupts = 0;
	for (k = 0; k < BANDAS; k++)
		bandas[k] = 0;
	uartConfig(UART_232, 9600);
	for (k = 0; k < CantMuestras; k++) {
		senial[k] = 0;
	}
	calculationFlag = 1;
	uint32_t TICKS_ADC = Timer_microsecondsToTicks(100);	//25 KHz
	Timer_Init(TIMER0, TICKS_ADC, TIMER_IRQ);
	adcConfig(BASS_SPECTRUM);
	dacConfig(DAC_ENABLE);

}

//void LED_REF(void) {
//	ledsControl(bandas);
//}
#define atenuacion 7
void calcularBandas() {
	int i;
	long long med;
	for (i = 0; i < 1024; i++)
		imag[i] = 0;
	memcpy(real, senial, 1024 * sizeof(int));

	for (i = 0; i < 8; i++)
		bandas[i] = 0;
	window(real,1024);
	fix_fft(real, imag, 10, 0);//TODO BANDAS puto
	////////////////////////////////////////////////////////////////////////////////BANDA 0
	med = 0;
	volatile int a = 0, b = 13;
	for (i = a; i < b; i++) {
		med += ((long long) ((pow(real[i], 2) + pow(imag[i], 2))) << 1);
	}
	bandas[0] = (med / (b - a)) >> atenuacion+1;

	////////////////////////////////////////////////////////////////////////////////BANDA 1
	med = 0;
	a = 14;
	b = 30;
	for (i = a; i < b; i++) {
		med += ((long long) ((pow(real[i], 2) + pow(imag[i], 2))) << 1);
	}
	bandas[1] = (med / (b - a)) >> atenuacion;
	////////////////////////////////////////////////////////////////////////////////BANDA 2

	med = 0;
	a = 31;
	b = 70;
	for (i = a; i < b; i++) {
		med += ((long long) ((pow(real[i], 2) + pow(imag[i], 2))) << 1);
	}
	bandas[2] = (med / (b - a)) >> atenuacion-2;
	////////////////////////////////////////////////////////////////////////////////BANDA 3

	med = 0;
	a = 71;
	b = 130;
	for (i = a; i < b; i++) {
		med += ((long long) ((pow(real[i], 2) + pow(imag[i], 2))) << 1);
	}
	bandas[3] = (med / (b - a)) >> atenuacion-4;
	////////////////////////////////////////////////////////////////////////////////BANDA 4
	a = 131;
	b = 210;
	med = 0;
	for (i = a; i < b; i++) {
		med += ((long long) ((pow(real[i], 2) + pow(imag[i], 2))) << 1);
	}
	bandas[4] = (med / (b - a)) >> atenuacion-4;
	////////////////////////////////////////////////////////////////////////////////BANDA 5
	a = 211;
	b = 310;
	med = 0;
	for (i = a; i < b; i++) {
		med += ((long long) ((pow(real[i], 2) + pow(imag[i], 2))) << 1);
	}
	bandas[5] = (med / (b - a)) >> atenuacion-4;
	////////////////////////////////////////////////////////////////////////////////BANDA 6
	a = 311;
	b = 410;
	med = 0;
	for (i = a; i < b; i++) {
		med += ((long long) ((pow(real[i], 2) + pow(imag[i], 2))) << 1);
	}
	bandas[6] = (med / (b - a)) >> atenuacion-5;
	bandas[6] *=1.55f;
	////////////////////////////////////////////////////////////////////////////////BANDA 7
	a = 411;
	b = 512;
	med = 0;
	for (i = a; i < b; i++) {
		med += ((long long) ((pow(real[i], 2) + pow(imag[i], 2))) << 1);
	}
	bandas[7] = (med / (b - a)) >> atenuacion-5;
	bandas[7] *=1.55f;
}

void mostrarFFT(void) {
	if (calculationFlag == 1) {
		calcularBandas();
		calculationFlag = 0;
	}

	if (muestra) {
		ledsControl(bandas);
	} else
		ledsControl(todoUNO);
}

void cambiarFiltros(int c) {
	static int i;
	switch (c) {
	case 1:
		if (vfiltros[i] < 8) {
			vfiltros[i]++;
			flagCambioFiltros = 1;
		}
		break; /* optional */

	case 3:
		if (i > 0)
			i--;
		break; /* optional */

	case 4:
		if (vfiltros[i] > 0) {
			vfiltros[i]--;
			flagCambioFiltros = 1;
		}
		break; /* optional */

	case 5:
		if (i < 7)
			i++;
		break; /* optional */
	}
	ledsControl(vfiltros);
	mostrarFiltrado();

//TODO: El DAC tiene que estar haciendo sonar la señal, estos filtros la actualizan en tiempo real
}

int main(void) {
	setup();

	unsigned char car, c;
	unsigned char car_ant = '7';

	while (1) {

		car_ant = car;
		car = receivedByte;
		if (car != car_ant) {
			switch (car_ant) {

			case '0':
				state = MOSTRARFFT;	//Hace la FFT de la entrada del ADC

				break; /* optional */

			case '1':
				if (state == CAMBIARFILTROS)
					c = 1;
				break; /* optional */

			case '2':
				state = MOSTRARFILTRADO;	//Recibe que

				break; /* optional */

			case '3':
				if (state == CAMBIARFILTROS)
					c = 3;
				break; /* optional */

			case '4':
				if (state == CAMBIARFILTROS)
					c = 4;//Saca la señal filtrada por el DAC y hace la FFT de la misma
				break; /* optional */

			case '5':
				if (state == CAMBIARFILTROS)
					c = 5;	//Hace la FFT de la entrada del ADC
				break; /* optional */

			case '6':
				state = CAMBIARFILTROS;	//Recibe que

				break; /* optional */

			}
			car_ant = '0';
		}
		switch (state) {

		case MOSTRARFFT:

			mostrarFFT();
			break; /* optional */

		case CAMBIARFILTROS:

			cambiarFiltros(c);
			c = 0;
			break; /* optional */

		case MOSTRARFILTRADO:

			mostrarFiltrado();
			//filtra(); //Saca la señal filtrada por el DAC y hace la FFT de la misma
			break; /* optional */
		}

	}

	return 0;
}
